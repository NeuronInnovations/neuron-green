<script type="text/html" data-template-name="stderr r">
    <div class="form-row">
        <label for="node-input-name"><span>Name</span></label>
        <input type="text" id="node-input-name" placeholder="Stderr">
    </div>
    <div class="form-row">
        <label for="node-input-nodeType"> <span>Node Type</span></label>
        <select id="node-input-nodeType" style="width: 100%;">
            <option value="buyer config">Buyer</option>
            <option value="seller config">Seller</option>
        </select>
    </div>
    <div class="form-row">
        <label for="node-input-selectedNode"> <span>Selected Node</span></label>
        <input type="hidden" id="node-input-selectedNode" />
        <input type="text" id="node-input-selectedNodeDisplay" placeholder="No node selected" readonly disabled>
        <button type="button" id="node-input-selectNode-btn" class="red-ui-button" style="margin-left: 5px; background-color: #489cb5; color: white;">
            Select node
        </button>
        <button type="button" id="node-input-clearNode-btn" class="red-ui-button" style="margin-left: 5px;" title="Clear selection">
            Clear
        </button>
    </div>
  <!--  <div class="form-row">
        <label for="node-input-selectedNode"> <span>Selected Node</span></label>
        <input type="text" id="node-input-selectedNode" placeholder="Select a node">
        <button type="button" id="node-input-selectNode-btn" class="red-ui-button" style="margin-left: 5px;">
            Select node
        </button>
    </div>-->
</script>

<script type="text/javascript">
    RED.nodes.registerType('stderr r', {
        category: 'Neuron',
        color: '#1DA665',
        defaults: {
            name: { value: "" },
            selectedNode: { value: "", required: true },
            nodeType: { value: "buyer config" }
        },
        inputs: 1,
        outputs: 0,
        icon: "error.svg",
        align: "left",
        label: function() {
            return this.name || "Stderr";
        },
        oneditprepare: function() {
            const node = this;
            const selectedNodeInput = $('#node-input-selectedNode');
            const selectedNodeDisplayInput = $('#node-input-selectedNodeDisplay');
            // Add custom styles
            $('<style>')
                .text(`
                    .buyer-node-table {
                        width: 100%;
                        border-collapse: collapse;
                        margin-bottom: 10px;
                    }
                    .buyer-node-table th {
                        padding: 8px;
                        text-align: left;
                        border-bottom: 2px solid #ddd;
                        font-weight: bold;
                    }
                    .buyer-node-table td {
                        padding: 8px;
                        border-bottom: 1px solid #ddd;
                        vertical-align: middle;
                    }
                    .buyer-node-table tr:hover {
                        background-color: #f5f5f5;
                        color: black;
                        cursor: pointer;
                    }
                    .buyer-node-table .select-btn {
                        padding: 4px 8px;
                        background-color: #1DA665;
                        color: black;
                        border: none;
                        border-radius: 3px;
                        cursor: pointer;
                        opacity: 0;
                        transition: opacity 0.2s;
                    }
                    .buyer-node-table tr:hover .select-btn {
                        opacity: 1;
                    }
                    .buyer-node-table .select-btn:hover {
                        background-color: #189c5a;
                    }
                    .buyer-node-table .node-name {
                        font-weight: 500;
                    }
                    .buyer-node-table .node-type {
                        color: #666;
                        font-size: 0.9em;
                    }
                `)
                .appendTo('head');
            
            // Function to update the input field with selected node info
            function updateNodeInput(nodeId, nodeName) {
                selectedNodeInput.val(nodeId);
                selectedNodeDisplayInput.val(nodeName);
                // $('#node-input-selectedNode').val(nodeId);
            }

            $('#node-input-clearNode-btn').click(function () {
                console.log('Clear node button clicked'); // Debug log
                selectedNodeInput.val('');
                selectedNodeDisplayInput.val('No node selected');
            });

            // Set initial node type
            if (node.nodeType) {
                $('#node-input-nodeType').val(node.nodeType);
            }

                // Set initial value if exists
                if (node.selectedNode) {
                   // console.log('Initial node selected ', node.selectedNode); // Debug log
                    const selectedNode = RED.nodes.node(node.selectedNode);
                    if (selectedNode) {
                        updateNodeInput(selectedNode.id, selectedNode.name || selectedNode.id);
                    } else {
                        // Node no longer exists, clear the selection
                        selectedNodeInput.val('');
                        selectedNodeDisplayInput.val('Node not found');
                    }
                }

            // Handle the search button click
            $('#node-input-selectNode-btn').click(function() {
                const selectedType = $('#node-input-nodeType').val();
                const dialog = $('<div>').dialog({
                    title: `Select ${selectedType.charAt(0).toUpperCase() + selectedType.slice(1)} Node`,
                    width: 600,
                    height: 400,
                    modal: true,
                    buttons: [
                        {
                            text: "Cancel",
                            click: function() {
                                $(this).dialog("close");
                            }
                        }
                    ]
                });

                // Create a table to show available nodes
                const table = $('<table>').addClass('buyer-node-table');
                const thead = $('<thead>').append(
                    $('<tr>').append(
                        $('<th>').text("Name").css('width', '70%'),
                        $('<th>').text("Type").css('width', '20%'),
                        $('<th>').css('width', '10%')
                    )
                );
                table.append(thead);

                const tbody = $('<tbody>');
                
                // Find all nodes of selected type in the workspace and sort them by name
                const nodes = [];
                RED.nodes.eachNode(function(n) {
                    if (n.type === selectedType) {
                        nodes.push(n);
                    }
                });
                
                // Sort nodes by name
                nodes.sort((a, b) => {
                    const nameA = (a.name || a.id).toLowerCase();
                    const nameB = (b.name || b.id).toLowerCase();
                    return nameA.localeCompare(nameB);
                });

                // Add sorted nodes to table
                nodes.forEach(function(n) {
                    const row = $('<tr>').append(
                        $('<td>').addClass('node-name').text(n.name || n.id),
                        $('<td>').addClass('node-type').text(n.type),
                        $('<td>').append(
                            $('<button>')
                                .addClass('select-btn')
                                .text('Select')
                                .click(function(e) {
                                    e.stopPropagation();
                                    updateNodeInput(n.id, n.name || n.id);
                                    dialog.dialog("close");
                                })
                        )
                    );
                    
                    // Add click handler for the entire row
                    row.click(function() {
                        updateNodeInput(n.id, n.name || n.id);
                        dialog.dialog("close");
                    });
                    
                    tbody.append(row);
                });

                table.append(tbody);
                dialog.append(table);

         
            });

            // Make the input field read-only
            selectedNodeInput.prop('readonly', true);
        },
        oneditsave: function() {
            this.nodeType = $('#node-input-nodeType').val();
        }
    });
</script>

<script type="text/x-red" data-help-name="stderr r">
    <p>A node that writes error messages to the STDERR Hedera topic of a selected device.</p>
    
    <h3>Overview</h3>
    <p>The Stderr Write node sends error messages to the STDERR topic (topic[2]) of a selected buyer or seller device. This is analogous to writing to stderr in traditional UNIX systems, but implemented over Hedera blockchain topics.</p>
    
    <h3>Inputs</h3>
    <dl class="message-properties">
        <dt>topic <span class="property-type">any</span></dt>
        <dd>The error message or data to write to the device's STDERR topic. This field is used as the payload.</dd>
    </dl>
    
    <h3>Outputs</h3>
    <p>This node has no outputs. It only writes to the Hedera topic.</p>
    
    <h3>Configuration</h3>
    <ul>
        <li><b>Name</b>: Optional name for the node</li>
        <li><b>Node Type</b>: Select between "Buyer" or "Seller" to filter available nodes</li>
        <li><b>Selected Node</b>: Choose the specific buyer or seller device to write to</li>
    </ul>
    
    <h3>Message Structure</h3>
    <p>The node automatically creates a structured error message containing:</p>
    <pre>
{
    "timestamp": "2024-01-01T12:00:00.000Z",
    "selectedNodeId": "node_id",
    "deviceInfo": {
        "address": "device_evm_address",
        "deviceType": "device_type",
        "serialNumber": "serial_number"
    },
    "payload": msg.topic
}
    </pre>
    
    <h3>Error Logging and Reporting</h3>
    <ul>
        <li><b>Target Topic</b>: Uses the device's STDERR topic (topics[2])</li>
        <li><b>Authentication</b>: Uses the device's private key and account ID</li>
        <li><b>Message Format</b>: JSON-encoded structured error message</li>
        <li><b>Persistence</b>: Error messages are permanently stored on Hedera network</li>
        <li><b>Traceability</b>: Includes device information for error tracking</li>
    </ul>
    
    <h3>Use Cases</h3>
    <ul>
        <li>Logging system errors and exceptions</li>
        <li>Recording device malfunctions or failures</li>
        <li>Documenting validation errors and warnings</li>
        <li>Creating audit trails for troubleshooting</li>
        <li>Alerting about critical system states</li>
        <li>Debugging distributed device networks</li>
    </ul>
    
    <h3>Error Message Types</h3>
    <p>Common error patterns to log to STDERR:</p>
    <ul>
        <li><b>System Errors</b>: Hardware failures, resource exhaustion</li>
        <li><b>Network Errors</b>: Connection failures, timeout errors</li>
        <li><b>Data Errors</b>: Validation failures, format errors</li>
        <li><b>Configuration Errors</b>: Invalid settings, missing parameters</li>
        <li><b>Security Errors</b>: Authentication failures, access denied</li>
        <li><b>Process Errors</b>: Task failures, workflow interruptions</li>
    </ul>
    
    <h3>Status Indicators</h3>
    <ul>
        <li><span style="color:green">●</span> initialized for [node]: Ready to log errors</li>
        <li><span style="color:blue">●</span> sending...: Error message transmission in progress</li>
        <li><span style="color:green">●</span> [time] sent to topic [id]: Error message successfully logged</li>
        <li><span style="color:red">●</span> no node selected: Configuration error</li>
        <li><span style="color:red">●</span> init failed: Hedera service initialization failed</li>
    </ul>
    
    <h3>Error Monitoring Integration</h3>
    <ul>
        <li><b>Centralized Logging</b>: All device errors in one Hedera topic</li>
        <li><b>Real-time Monitoring</b>: Use topic listeners for immediate alerts</li>
        <li><b>Historical Analysis</b>: Query topic history for error patterns</li>
        <li><b>Cross-Device Correlation</b>: Compare errors across multiple devices</li>
    </ul>
    
    <h3>Prerequisites</h3>
    <ul>
        <li>Selected device must be deployed and initialized</li>
        <li>Device must have valid Hedera account and topics</li>
        <li>Hedera credentials must be properly configured</li>
        <li>Device information must be persisted in the local file system</li>
        <li>STDERR topic (topics[2]) must exist and be accessible</li>
    </ul>
    
    <h3>Best Practices</h3>
    <ul>
        <li><b>Structured Errors</b>: Use consistent error message formats</li>
        <li><b>Severity Levels</b>: Include error severity in message payload</li>
        <li><b>Context Information</b>: Add relevant system state and parameters</li>
        <li><b>Error Codes</b>: Use standardized error codes for categorization</li>
        <li><b>Timestamps</b>: Ensure accurate timing for error correlation</li>
        <li><b>Rate Limiting</b>: Avoid flooding stderr with duplicate errors</li>
    </ul>
    
    <h3>Debugging and Troubleshooting</h3>
    <ul>
        <li><b>Error Correlation</b>: Link errors with related system events</li>
        <li><b>Pattern Recognition</b>: Identify recurring error conditions</li>
        <li><b>Root Cause Analysis</b>: Use error logs to trace issue origins</li>
        <li><b>System Health</b>: Monitor error rates for device health</li>
    </ul>
    
    <h3>Error Handling</h3>
    <ul>
        <li>Validates device information before logging</li>
        <li>Checks for valid topics array and STDERR topic existence</li>
        <li>Gracefully handles logging failures without breaking workflow</li>
        <li>Reports meta-errors if STDERR logging itself fails</li>
    </ul>
    
    <h3>Security and Privacy</h3>
    <ul>
        <li><b>Sensitive Data</b>: Avoid logging sensitive information in error messages</li>
        <li><b>Access Control</b>: STDERR topics may be readable by authorized parties</li>
        <li><b>Data Retention</b>: Hedera topics persist permanently - consider implications</li>
        <li><b>Error Masking</b>: Sanitize error messages that might expose system details</li>
    </ul>
    
    <h3>Related Nodes</h3>
    <ul>
        <li><b>stdout w</b>: Write output messages to a device's STDOUT topic</li>
        <li><b>stdin r</b>: Read input messages from a device's STDIN topic</li>
        <li><b>stdin w</b>: Write input messages to another device's STDIN topic</li>
        <li><b>debug</b>: Node-RED built-in debugging for local error display</li>
    </ul>
</script> 